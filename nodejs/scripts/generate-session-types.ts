/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------------------------------------------*/

/**
 * Generate session event types for all SDKs from the JSON schema
 *
 * This script reads the session-events.schema.json from the @github/copilot package
 * (which should be npm linked from copilot-agent-runtime/dist-cli) and generates
 * TypeScript, Python, Go, and C# type definitions for all SDKs.
 *
 * Workflow:
 * 1. The schema is defined in copilot-agent-runtime using Zod schemas
 * 2. copilot-agent-runtime/script/generate-session-types.ts generates the JSON schema
 * 3. copilot-agent-runtime/esbuild.ts copies the schema to dist-cli/
 * 4. This script reads the schema from the linked @github/copilot package
 * 5. Generates types for nodejs/src/generated/, python/copilot/generated/, go/generated/, and dotnet/src/Generated/
 *
 * Usage:
 *   npm run generate:session-types
 */

import { execFile } from "child_process";
import fs from "fs/promises";
import type { JSONSchema7, JSONSchema7Definition } from "json-schema";
import { compile } from "json-schema-to-typescript";
import path from "path";
import { FetchingJSONSchemaStore, InputData, JSONSchemaInput, quicktype } from "quicktype-core";
import { fileURLToPath } from "url";
import { promisify } from "util";
import { generateCSharpSessionTypes } from "./generate-csharp-session-types.js";

const execFileAsync = promisify(execFile);

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Locates the JSON schema file from the @github/copilot package.
 * Throws an error with helpful instructions if the schema cannot be found.
 */
async function getSchemaPath(): Promise<string> {
    const schemaPath = path.join(
        __dirname,
        "../node_modules/@github/copilot/schemas/session-events.schema.json"
    );

    try {
        await fs.access(schemaPath);
        console.log(`Found schema at: ${schemaPath}`);
        return schemaPath;
    } catch (_error) {
        throw new Error(
            `Schema file not found at ${schemaPath}. ` +
                `Ensure @github/copilot package is installed or linked. ` +
                `Run 'npm install' or check the package installation.`
        );
    }
}

async function generateTypeScriptTypes(schemaPath: string) {
    console.log("Generating TypeScript types from JSON Schema...");

    let schemaContent: string;
    try {
        schemaContent = await fs.readFile(schemaPath, "utf-8");
    } catch (error) {
        throw new Error(
            `Failed to read schema file at ${schemaPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    let schema: JSONSchema7;
    try {
        schema = JSON.parse(schemaContent) as JSONSchema7;
    } catch (error) {
        throw new Error(
            `Failed to parse JSON schema from ${schemaPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    const processedSchema = postProcessSchema(schema);

    let ts: string;
    try {
        ts = await compile(processedSchema, "SessionEvent", {
            bannerComment: `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated from: @github/copilot/session-events.schema.json
 * Generated by: scripts/generate-session-types.ts
 * Generated at: ${new Date().toISOString()}
 *
 * To update these types:
 * 1. Update the schema in copilot-agent-runtime
 * 2. Run: npm run generate:session-types
 */`,
            style: {
                semi: true,
                singleQuote: false,
                trailingComma: "all",
            },
            additionalProperties: false, // Stricter types
        });
    } catch (error) {
        throw new Error(
            `Failed to compile TypeScript types from schema: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    const outputPath = path.join(__dirname, "../src/generated/session-events.ts");
    try {
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
        await fs.writeFile(outputPath, ts, "utf-8");
    } catch (error) {
        throw new Error(
            `Failed to write TypeScript types to ${outputPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    console.log(`Generated TypeScript types: ${outputPath}`);
}

/**
 * Event types to exclude from generation (internal/legacy types)
 */
const EXCLUDED_EVENT_TYPES = new Set(["session.import_legacy"]);

/**
 * Post-process JSON Schema to make it compatible with quicktype
 * Converts boolean const values to enum with single value
 * Filters out excluded event types
 */
function postProcessSchema(schema: JSONSchema7): JSONSchema7 {
    if (typeof schema !== "object" || schema === null) {
        return schema;
    }

    const processed: JSONSchema7 = { ...schema };

    // Handle const with boolean values - convert to enum with single value
    if ("const" in processed && typeof processed.const === "boolean") {
        const constValue = processed.const;
        delete processed.const;
        processed.enum = [constValue];
    }

    // Recursively process all properties
    if (processed.properties) {
        const newProperties: Record<string, JSONSchema7Definition> = {};
        for (const [key, value] of Object.entries(processed.properties)) {
            if (typeof value === "object" && value !== null) {
                newProperties[key] = postProcessSchema(value as JSONSchema7);
            } else {
                newProperties[key] = value;
            }
        }
        processed.properties = newProperties;
    }

    // Process items (for arrays)
    if (processed.items) {
        if (typeof processed.items === "object" && !Array.isArray(processed.items)) {
            processed.items = postProcessSchema(processed.items as JSONSchema7);
        } else if (Array.isArray(processed.items)) {
            processed.items = processed.items.map((item) =>
                typeof item === "object" ? postProcessSchema(item as JSONSchema7) : item
            ) as JSONSchema7Definition[];
        }
    }

    // Process anyOf, allOf, oneOf - also filter out excluded event types
    for (const combiner of ["anyOf", "allOf", "oneOf"] as const) {
        if (processed[combiner]) {
            processed[combiner] = processed[combiner]!.filter((item) => {
                if (typeof item !== "object") return true;
                const typeConst = (item as JSONSchema7).properties?.type;
                if (typeof typeConst === "object" && "const" in typeConst) {
                    return !EXCLUDED_EVENT_TYPES.has(typeConst.const as string);
                }
                return true;
            }).map((item) =>
                typeof item === "object" ? postProcessSchema(item as JSONSchema7) : item
            ) as JSONSchema7Definition[];
        }
    }

    // Process definitions
    if (processed.definitions) {
        const newDefinitions: Record<string, JSONSchema7Definition> = {};
        for (const [key, value] of Object.entries(processed.definitions)) {
            if (typeof value === "object" && value !== null) {
                newDefinitions[key] = postProcessSchema(value as JSONSchema7);
            } else {
                newDefinitions[key] = value;
            }
        }
        processed.definitions = newDefinitions;
    }

    // Process additionalProperties if it's a schema
    if (typeof processed.additionalProperties === "object") {
        processed.additionalProperties = postProcessSchema(
            processed.additionalProperties as JSONSchema7
        );
    }

    return processed;
}

async function generatePythonTypes(schemaPath: string) {
    console.log("Generating Python types from JSON Schema...");

    let schemaContent: string;
    try {
        schemaContent = await fs.readFile(schemaPath, "utf-8");
    } catch (error) {
        throw new Error(
            `Failed to read schema file at ${schemaPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    let schema: JSONSchema7;
    try {
        schema = JSON.parse(schemaContent) as JSONSchema7;
    } catch (error) {
        throw new Error(
            `Failed to parse JSON schema from ${schemaPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    // Resolve the $ref at the root level and get the actual schema
    const resolvedSchema = (schema.definitions?.SessionEvent as JSONSchema7) || schema;

    // Post-process to fix boolean const values
    const processedSchema = postProcessSchema(resolvedSchema);

    const schemaInput = new JSONSchemaInput(new FetchingJSONSchemaStore());
    await schemaInput.addSource({
        name: "SessionEvent",
        schema: JSON.stringify(processedSchema),
    });

    const inputData = new InputData();
    inputData.addInput(schemaInput);

    let result;
    try {
        result = await quicktype({
            inputData,
            lang: "python",
            rendererOptions: {
                "python-version": "3.7",
            },
        });
    } catch (error) {
        throw new Error(
            `Failed to generate Python types using quicktype: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    let generatedCode = result.lines.join("\n");

    // Fix Python dataclass field ordering issue:
    // Quicktype doesn't support default values in schemas, so it generates "arguments: Any"
    // (without default) that comes after Optional fields (with defaults), violating Python's
    // dataclass rules. We post-process to add "= None" to these unconstrained "Any" fields.
    generatedCode = generatedCode.replace(/: Any$/gm, ": Any = None");

    // Add UNKNOWN enum value and _missing_ handler for forward compatibility
    // This ensures that new event types from the server don't cause errors
    generatedCode = generatedCode.replace(
        /^(class SessionEventType\(Enum\):.*?)(^\s*\n@dataclass)/ms,
        `$1    # UNKNOWN is used for forward compatibility - new event types from the server
    # will map to this value instead of raising an error
    UNKNOWN = "unknown"

    @classmethod
    def _missing_(cls, value: object) -> "SessionEventType":
        """Handle unknown event types gracefully for forward compatibility."""
        return cls.UNKNOWN

$2`
    );

    const banner = `"""
AUTO-GENERATED FILE - DO NOT EDIT

Generated from: @github/copilot/session-events.schema.json
Generated by: scripts/generate-session-types.ts
Generated at: ${new Date().toISOString()}

To update these types:
1. Update the schema in copilot-agent-runtime
2. Run: npm run generate:session-types
"""

`;

    const outputPath = path.join(__dirname, "../../python/copilot/generated/session_events.py");
    try {
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
        await fs.writeFile(outputPath, banner + generatedCode, "utf-8");
    } catch (error) {
        throw new Error(
            `Failed to write Python types to ${outputPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    console.log(`Generated Python types: ${outputPath}`);
}

/**
 * Formats a Go file using 'go fmt'.
 * Non-critical operation: logs a warning if formatting fails but does not throw.
 */
async function formatGoFile(filePath: string): Promise<void> {
    try {
        await execFileAsync("go", ["fmt", filePath]);
        console.log(`Formatted Go file with go fmt: ${filePath}`);
    } catch (error: unknown) {
        // Formatting is optional and should not break the build
        if (error instanceof Error && "code" in error) {
            const nodeError = error as NodeJS.ErrnoException;
            if (nodeError.code === "ENOENT") {
                console.warn(
                    `Warning: 'go' command not found. Skipping Go file formatting. Install Go toolchain if formatting is needed.`
                );
            } else {
                console.warn(
                    `Warning: 'go fmt' failed for ${filePath}: ${error.message}. File generated but not formatted.`
                );
            }
        } else {
            console.warn(
                `Warning: Unexpected error during Go formatting: ${String(error)}. File generated but not formatted.`
            );
        }
    }
}

async function generateGoTypes(schemaPath: string) {
    console.log("Generating Go types from JSON Schema...");

    let schemaContent: string;
    try {
        schemaContent = await fs.readFile(schemaPath, "utf-8");
    } catch (error) {
        throw new Error(
            `Failed to read schema file at ${schemaPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    let schema: JSONSchema7;
    try {
        schema = JSON.parse(schemaContent) as JSONSchema7;
    } catch (error) {
        throw new Error(
            `Failed to parse JSON schema from ${schemaPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    // Resolve the $ref at the root level and get the actual schema
    const resolvedSchema = (schema.definitions?.SessionEvent as JSONSchema7) || schema;

    // Post-process to fix boolean const values
    const processedSchema = postProcessSchema(resolvedSchema);

    const schemaInput = new JSONSchemaInput(new FetchingJSONSchemaStore());
    await schemaInput.addSource({
        name: "SessionEvent",
        schema: JSON.stringify(processedSchema),
    });

    const inputData = new InputData();
    inputData.addInput(schemaInput);

    let result;
    try {
        result = await quicktype({
            inputData,
            lang: "go",
            rendererOptions: {
                package: "copilot",
            },
        });
    } catch (error) {
        throw new Error(
            `Failed to generate Go types using quicktype: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    const generatedCode = result.lines.join("\n");
    const banner = `// AUTO-GENERATED FILE - DO NOT EDIT
//
// Generated from: @github/copilot/session-events.schema.json
// Generated by: scripts/generate-session-types.ts
// Generated at: ${new Date().toISOString()}
//
// To update these types:
// 1. Update the schema in copilot-agent-runtime
// 2. Run: npm run generate:session-types

`;

    const outputPath = path.join(__dirname, "../../go/generated_session_events.go");
    try {
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
        await fs.writeFile(outputPath, banner + generatedCode, "utf-8");
    } catch (error) {
        throw new Error(
            `Failed to write Go types to ${outputPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    console.log(`Generated Go types: ${outputPath}`);

    await formatGoFile(outputPath);
}

/**
 * Formats a C# file using 'dotnet format'.
 * Non-critical operation: logs a warning if formatting fails but does not throw.
 */
async function formatCSharpFile(filePath: string): Promise<void> {
    try {
        // Get the directory containing the .csproj file
        const projectDir = path.join(__dirname, "../../dotnet/src");
        const projectFile = path.join(projectDir, "GitHub.Copilot.SDK.csproj");

        // dotnet format needs to be run from the project directory or with --workspace
        await execFileAsync("dotnet", ["format", projectFile, "--include", filePath]);
        console.log(`Formatted C# file with dotnet format: ${filePath}`);
    } catch (error: unknown) {
        // Formatting is optional and should not break the build
        if (error instanceof Error && "code" in error) {
            const nodeError = error as NodeJS.ErrnoException;
            if (nodeError.code === "ENOENT") {
                console.warn(
                    `Warning: 'dotnet' command not found. Skipping C# file formatting. Install .NET SDK if formatting is needed.`
                );
            } else {
                console.warn(
                    `Warning: 'dotnet format' failed for ${filePath}: ${error.message}. File generated but not formatted.`
                );
            }
        } else {
            console.warn(
                `Warning: Unexpected error during C# formatting: ${String(error)}. File generated but not formatted.`
            );
        }
    }
}

async function generateCSharpTypes(schemaPath: string) {
    console.log("Generating C# types from JSON Schema...");

    let schemaContent: string;
    try {
        schemaContent = await fs.readFile(schemaPath, "utf-8");
    } catch (error) {
        throw new Error(
            `Failed to read schema file at ${schemaPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    let schema: JSONSchema7;
    try {
        schema = JSON.parse(schemaContent) as JSONSchema7;
    } catch (error) {
        throw new Error(
            `Failed to parse JSON schema from ${schemaPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    const generatedAt = new Date().toISOString();
    let generatedCode: string;
    try {
        generatedCode = generateCSharpSessionTypes(schema, generatedAt);
    } catch (error) {
        throw new Error(
            `Failed to generate C# types from schema: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    const outputPath = path.join(__dirname, "../../dotnet/src/Generated/SessionEvents.cs");
    try {
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
        await fs.writeFile(outputPath, generatedCode, "utf-8");
    } catch (error) {
        throw new Error(
            `Failed to write C# types to ${outputPath}: ${error instanceof Error ? error.message : String(error)}`
        );
    }

    console.log(`Generated C# types: ${outputPath}`);

    await formatCSharpFile(outputPath);
}

async function main() {
    try {
        console.log("Starting type generation from JSON Schema...\n");

        const schemaPath = await getSchemaPath();

        // Generate types for all SDKs sequentially to ensure clear error reporting
        await generateTypeScriptTypes(schemaPath);
        await generatePythonTypes(schemaPath);
        await generateGoTypes(schemaPath);
        await generateCSharpTypes(schemaPath);

        console.log("\nType generation completed successfully.");
    } catch (error) {
        // Log detailed error information for debugging
        console.error("\nType generation failed:");
        if (error instanceof Error) {
            console.error(`Error: ${error.message}`);
            if (error.stack) {
                console.error("\nStack trace:");
                console.error(error.stack);
            }
        } else {
            console.error(String(error));
        }

        // Exit with non-zero code to indicate failure in CI/CD pipelines
        process.exit(1);
    }
}

main();
