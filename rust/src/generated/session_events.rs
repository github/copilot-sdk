// AUTO-GENERATED FILE - DO NOT EDIT
//
// Generated from: @github/copilot/session-events.schema.json
// Generated by: scripts/generate-session-types.ts
//
// To update these types:
// 1. Update the schema in copilot-agent-runtime
// 2. Run: npm run generate:session-types

//! Session event types for the Copilot SDK.
//!
//! This module contains types representing events emitted by Copilot sessions
//! during conversation processing. Events cover the full lifecycle of a session,
//! including message handling, tool execution, and session state changes.
//!
//! # Event Flow
//!
//! A typical session flow emits events in this order:
//!
//! 1. [`SessionEventType::SessionStart`] - Session created
//! 2. [`SessionEventType::UserMessage`] - User message received
//! 3. [`SessionEventType::AssistantTurnStart`] - Assistant begins processing
//! 4. [`SessionEventType::AssistantMessageDelta`] - Streaming response chunks (if enabled)
//! 5. [`SessionEventType::AssistantMessage`] - Complete assistant response
//! 6. [`SessionEventType::AssistantTurnEnd`] - Assistant finished processing
//! 7. [`SessionEventType::SessionIdle`] - Session ready for next message
//!
//! # Tool Execution
//!
//! When the assistant invokes tools:
//!
//! 1. [`SessionEventType::ToolExecutionStart`] - Tool execution begins
//! 2. [`SessionEventType::ToolExecutionPartialResult`] - Intermediate results (optional)
//! 3. [`SessionEventType::ToolExecutionComplete`] - Tool execution finished
//!
//! # Example
//!
//! ```ignore
//! use copilot_sdk::{SessionEvent, SessionEventType};
//!
//! fn handle_event(event: &SessionEvent) {
//!     match event.event_type {
//!         SessionEventType::AssistantMessage => {
//!             if let Some(content) = &event.data.content {
//!                 println!("Assistant: {}", content);
//!             }
//!         }
//!         SessionEventType::SessionError => {
//!             if let Some(msg) = &event.data.message {
//!                 eprintln!("Error: {}", msg);
//!             }
//!         }
//!         _ => {}
//!     }
//! }
//! ```

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Session event from the Copilot CLI.
///
/// This is the primary event structure emitted by sessions during processing.
/// Each event has a type, timestamp, unique ID, and type-specific data.
///
/// # Fields
///
/// - `event_type` - The type of event (see [`SessionEventType`])
/// - `id` - Unique identifier for this event
/// - `timestamp` - When the event occurred
/// - `data` - Event-specific data (see [`SessionEventData`])
/// - `parent_id` - ID of parent event (for nested events)
/// - `ephemeral` - Whether this event should be persisted
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionEvent {
    /// Event-specific data payload.
    ///
    /// This is a flat structure containing all possible fields for all event types.
    /// Only fields relevant to the specific `event_type` will be populated.
    pub data: SessionEventData,

    /// Whether the event is ephemeral (not persisted to session history).
    ///
    /// Ephemeral events are typically used for streaming deltas and
    /// intermediate progress updates.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<bool>,

    /// Unique identifier for this event.
    ///
    /// Can be used to track specific events or correlate related events.
    pub id: String,

    /// Parent event ID (if this event is a child of another event).
    ///
    /// Used to establish event hierarchies, such as tool execution events
    /// being children of the message that triggered them.
    #[serde(rename = "parentId")]
    pub parent_id: Option<String>,

    /// Timestamp when this event occurred.
    pub timestamp: DateTime<Utc>,

    /// The type of this event.
    ///
    /// Determines which fields in `data` are populated and how the event
    /// should be interpreted.
    #[serde(rename = "type")]
    pub event_type: SessionEventType,
}

/// Session event types.
///
/// Each variant represents a different type of event that can occur during
/// a Copilot session. The event type determines which fields in
/// [`SessionEventData`] will be populated.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SessionEventType {
    /// Message processing was aborted.
    #[serde(rename = "abort")]
    Abort,

    /// Assistant expressed an intent or plan.
    #[serde(rename = "assistant.intent")]
    AssistantIntent,

    /// Complete assistant message.
    ///
    /// Contains the full response content in `data.content`.
    #[serde(rename = "assistant.message")]
    AssistantMessage,

    /// Streaming assistant message chunk.
    ///
    /// Contains incremental content in `data.delta_content`.
    /// Only emitted when streaming is enabled.
    #[serde(rename = "assistant.message_delta")]
    AssistantMessageDelta,

    /// Complete assistant reasoning (chain-of-thought).
    ///
    /// Contains the full reasoning content in `data.content`.
    /// Only available for models that support reasoning.
    #[serde(rename = "assistant.reasoning")]
    AssistantReasoning,

    /// Streaming assistant reasoning chunk.
    ///
    /// Contains incremental reasoning in `data.delta_content`.
    /// Only emitted when streaming is enabled and model supports reasoning.
    #[serde(rename = "assistant.reasoning_delta")]
    AssistantReasoningDelta,

    /// Assistant finished processing this turn.
    #[serde(rename = "assistant.turn_end")]
    AssistantTurnEnd,

    /// Assistant started processing this turn.
    #[serde(rename = "assistant.turn_start")]
    AssistantTurnStart,

    /// Token usage information for this turn.
    ///
    /// Contains `data.input_tokens`, `data.output_tokens`, etc.
    #[serde(rename = "assistant.usage")]
    AssistantUsage,

    /// Hook execution completed.
    #[serde(rename = "hook.end")]
    HookEnd,

    /// Hook execution started.
    #[serde(rename = "hook.start")]
    HookStart,

    /// Pending messages queue was modified.
    #[serde(rename = "pending_messages.modified")]
    PendingMessagesModified,

    /// Context compaction completed.
    #[serde(rename = "session.compaction_complete")]
    SessionCompactionComplete,

    /// Context compaction started.
    #[serde(rename = "session.compaction_start")]
    SessionCompactionStart,

    /// Session error occurred.
    ///
    /// Contains error details in `data.message`, `data.error_type`, `data.stack`.
    #[serde(rename = "session.error")]
    SessionError,

    /// Session handed off to another destination.
    #[serde(rename = "session.handoff")]
    SessionHandoff,

    /// Session is idle and ready for new messages.
    ///
    /// This event indicates the session has finished processing and is
    /// waiting for the next user message.
    #[serde(rename = "session.idle")]
    SessionIdle,

    /// Informational message about the session.
    #[serde(rename = "session.info")]
    SessionInfo,

    /// Model was changed during the session.
    ///
    /// Contains `data.previous_model` and `data.new_model`.
    #[serde(rename = "session.model_change")]
    SessionModelChange,

    /// Session was resumed from saved state.
    #[serde(rename = "session.resume")]
    SessionResume,

    /// Session was started.
    ///
    /// This is typically the first event emitted after creating a session.
    #[serde(rename = "session.start")]
    SessionStart,

    /// Context was truncated to fit within token limits.
    #[serde(rename = "session.truncation")]
    SessionTruncation,

    /// Usage information for the session.
    #[serde(rename = "session.usage_info")]
    SessionUsageInfo,

    /// Subagent completed execution.
    #[serde(rename = "subagent.completed")]
    SubagentCompleted,

    /// Subagent execution failed.
    #[serde(rename = "subagent.failed")]
    SubagentFailed,

    /// Subagent was selected for execution.
    #[serde(rename = "subagent.selected")]
    SubagentSelected,

    /// Subagent started execution.
    #[serde(rename = "subagent.started")]
    SubagentStarted,

    /// System message was added.
    #[serde(rename = "system.message")]
    SystemMessage,

    /// Tool execution completed.
    ///
    /// Contains tool result in `data.result`, tool name in `data.tool_name`.
    #[serde(rename = "tool.execution_complete")]
    ToolExecutionComplete,

    /// Partial tool execution result.
    ///
    /// Contains intermediate output in `data.partial_output`.
    #[serde(rename = "tool.execution_partial_result")]
    ToolExecutionPartialResult,

    /// Tool execution started.
    ///
    /// Contains tool name in `data.tool_name`, arguments in `data.arguments`.
    #[serde(rename = "tool.execution_start")]
    ToolExecutionStart,

    /// Tool was requested by user.
    #[serde(rename = "tool.user_requested")]
    ToolUserRequested,

    /// User message was added to the session.
    ///
    /// Contains message content in `data.content`, attachments in `data.attachments`.
    #[serde(rename = "user.message")]
    UserMessage,
}

impl std::fmt::Display for SessionEventType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SessionEventType::Abort => write!(f, "abort"),
            SessionEventType::AssistantIntent => write!(f, "assistant.intent"),
            SessionEventType::AssistantMessage => write!(f, "assistant.message"),
            SessionEventType::AssistantMessageDelta => write!(f, "assistant.message_delta"),
            SessionEventType::AssistantReasoning => write!(f, "assistant.reasoning"),
            SessionEventType::AssistantReasoningDelta => write!(f, "assistant.reasoning_delta"),
            SessionEventType::AssistantTurnEnd => write!(f, "assistant.turn_end"),
            SessionEventType::AssistantTurnStart => write!(f, "assistant.turn_start"),
            SessionEventType::AssistantUsage => write!(f, "assistant.usage"),
            SessionEventType::HookEnd => write!(f, "hook.end"),
            SessionEventType::HookStart => write!(f, "hook.start"),
            SessionEventType::PendingMessagesModified => write!(f, "pending_messages.modified"),
            SessionEventType::SessionCompactionComplete => write!(f, "session.compaction_complete"),
            SessionEventType::SessionCompactionStart => write!(f, "session.compaction_start"),
            SessionEventType::SessionError => write!(f, "session.error"),
            SessionEventType::SessionHandoff => write!(f, "session.handoff"),
            SessionEventType::SessionIdle => write!(f, "session.idle"),
            SessionEventType::SessionInfo => write!(f, "session.info"),
            SessionEventType::SessionModelChange => write!(f, "session.model_change"),
            SessionEventType::SessionResume => write!(f, "session.resume"),
            SessionEventType::SessionStart => write!(f, "session.start"),
            SessionEventType::SessionTruncation => write!(f, "session.truncation"),
            SessionEventType::SessionUsageInfo => write!(f, "session.usage_info"),
            SessionEventType::SubagentCompleted => write!(f, "subagent.completed"),
            SessionEventType::SubagentFailed => write!(f, "subagent.failed"),
            SessionEventType::SubagentSelected => write!(f, "subagent.selected"),
            SessionEventType::SubagentStarted => write!(f, "subagent.started"),
            SessionEventType::SystemMessage => write!(f, "system.message"),
            SessionEventType::ToolExecutionComplete => write!(f, "tool.execution_complete"),
            SessionEventType::ToolExecutionPartialResult => write!(f, "tool.execution_partial_result"),
            SessionEventType::ToolExecutionStart => write!(f, "tool.execution_start"),
            SessionEventType::ToolUserRequested => write!(f, "tool.user_requested"),
            SessionEventType::UserMessage => write!(f, "user.message"),
        }
    }
}

/// Session event data - a flat structure containing all possible fields.
///
/// This structure contains all possible fields for all event types.
/// Only fields relevant to the specific [`SessionEventType`] will be populated;
/// all others will be `None`.
///
/// # Common Fields by Event Type
///
/// | Event Type | Relevant Fields |
/// |------------|-----------------|
/// | `AssistantMessage` | `content`, `turn_id`, `message_id` |
/// | `AssistantMessageDelta` | `delta_content`, `message_id` |
/// | `UserMessage` | `content`, `attachments` |
/// | `SessionError` | `message`, `error_type`, `stack`, `error` |
/// | `ToolExecutionStart` | `tool_name`, `tool_call_id`, `arguments` |
/// | `ToolExecutionComplete` | `tool_name`, `tool_call_id`, `result` |
/// | `AssistantUsage` | `input_tokens`, `output_tokens`, `model`, `cost` |
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SessionEventData {
    /// Context information (working directory, git info, etc.).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<ContextUnion>,

    /// Copilot CLI version.
    #[serde(rename = "copilotVersion", skip_serializing_if = "Option::is_none")]
    pub copilot_version: Option<String>,

    /// Event producer identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub producer: Option<String>,

    /// Currently selected model.
    #[serde(rename = "selectedModel", skip_serializing_if = "Option::is_none")]
    pub selected_model: Option<String>,

    /// Session identifier.
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,

    /// Session start timestamp.
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<DateTime<Utc>>,

    /// Protocol version number.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<f64>,

    /// Total event count in session.
    #[serde(rename = "eventCount", skip_serializing_if = "Option::is_none")]
    pub event_count: Option<f64>,

    /// Session resume timestamp.
    #[serde(rename = "resumeTime", skip_serializing_if = "Option::is_none")]
    pub resume_time: Option<DateTime<Utc>>,

    /// Error type identifier.
    #[serde(rename = "errorType", skip_serializing_if = "Option::is_none")]
    pub error_type: Option<String>,

    /// Human-readable message content or error message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,

    /// Error stack trace.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stack: Option<String>,

    /// Info type for informational events.
    #[serde(rename = "infoType", skip_serializing_if = "Option::is_none")]
    pub info_type: Option<String>,

    /// New model (for model change events).
    #[serde(rename = "newModel", skip_serializing_if = "Option::is_none")]
    pub new_model: Option<String>,

    /// Previous model (for model change events).
    #[serde(rename = "previousModel", skip_serializing_if = "Option::is_none")]
    pub previous_model: Option<String>,

    /// Handoff timestamp.
    #[serde(rename = "handoffTime", skip_serializing_if = "Option::is_none")]
    pub handoff_time: Option<DateTime<Utc>>,

    /// Remote session ID (for handoffs).
    #[serde(rename = "remoteSessionId", skip_serializing_if = "Option::is_none")]
    pub remote_session_id: Option<String>,

    /// Repository information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,

    /// Source type (local or remote).
    #[serde(rename = "sourceType", skip_serializing_if = "Option::is_none")]
    pub source_type: Option<SourceType>,

    /// Summary text.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,

    /// Number of messages removed during context truncation.
    #[serde(rename = "messagesRemovedDuringTruncation", skip_serializing_if = "Option::is_none")]
    pub messages_removed_during_truncation: Option<f64>,

    /// Who performed the action.
    #[serde(rename = "performedBy", skip_serializing_if = "Option::is_none")]
    pub performed_by: Option<String>,

    /// Message count after truncation.
    #[serde(rename = "postTruncationMessagesLength", skip_serializing_if = "Option::is_none")]
    pub post_truncation_messages_length: Option<f64>,

    /// Token count after truncation.
    #[serde(rename = "postTruncationTokensInMessages", skip_serializing_if = "Option::is_none")]
    pub post_truncation_tokens_in_messages: Option<f64>,

    /// Message count before truncation.
    #[serde(rename = "preTruncationMessagesLength", skip_serializing_if = "Option::is_none")]
    pub pre_truncation_messages_length: Option<f64>,

    /// Token count before truncation.
    #[serde(rename = "preTruncationTokensInMessages", skip_serializing_if = "Option::is_none")]
    pub pre_truncation_tokens_in_messages: Option<f64>,

    /// Maximum token limit.
    #[serde(rename = "tokenLimit", skip_serializing_if = "Option::is_none")]
    pub token_limit: Option<f64>,

    /// Tokens removed during truncation.
    #[serde(rename = "tokensRemovedDuringTruncation", skip_serializing_if = "Option::is_none")]
    pub tokens_removed_during_truncation: Option<f64>,

    /// Current token count.
    #[serde(rename = "currentTokens", skip_serializing_if = "Option::is_none")]
    pub current_tokens: Option<f64>,

    /// Current message count.
    #[serde(rename = "messagesLength", skip_serializing_if = "Option::is_none")]
    pub messages_length: Option<f64>,

    /// Token usage for compaction operation.
    #[serde(rename = "compactionTokensUsed", skip_serializing_if = "Option::is_none")]
    pub compaction_tokens_used: Option<CompactionTokensUsed>,

    /// Detailed error information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorUnion>,

    /// Messages removed during compaction.
    #[serde(rename = "messagesRemoved", skip_serializing_if = "Option::is_none")]
    pub messages_removed: Option<f64>,

    /// Token count after compaction.
    #[serde(rename = "postCompactionTokens", skip_serializing_if = "Option::is_none")]
    pub post_compaction_tokens: Option<f64>,

    /// Message count before compaction.
    #[serde(rename = "preCompactionMessagesLength", skip_serializing_if = "Option::is_none")]
    pub pre_compaction_messages_length: Option<f64>,

    /// Token count before compaction.
    #[serde(rename = "preCompactionTokens", skip_serializing_if = "Option::is_none")]
    pub pre_compaction_tokens: Option<f64>,

    /// Whether the operation succeeded.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success: Option<bool>,

    /// Summary content from compaction.
    #[serde(rename = "summaryContent", skip_serializing_if = "Option::is_none")]
    pub summary_content: Option<String>,

    /// Tokens removed during operation.
    #[serde(rename = "tokensRemoved", skip_serializing_if = "Option::is_none")]
    pub tokens_removed: Option<f64>,

    /// Message attachments (files, directories).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Vec<Attachment>>,

    /// Text content of message or response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    /// Event source identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,

    /// Transformed content (after processing).
    #[serde(rename = "transformedContent", skip_serializing_if = "Option::is_none")]
    pub transformed_content: Option<String>,

    /// Turn identifier within the session.
    #[serde(rename = "turnId", skip_serializing_if = "Option::is_none")]
    pub turn_id: Option<String>,

    /// Assistant's stated intent.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intent: Option<String>,

    /// Reasoning chain identifier.
    #[serde(rename = "reasoningId", skip_serializing_if = "Option::is_none")]
    pub reasoning_id: Option<String>,

    /// Incremental content for streaming events.
    #[serde(rename = "deltaContent", skip_serializing_if = "Option::is_none")]
    pub delta_content: Option<String>,

    /// Message identifier.
    #[serde(rename = "messageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// Parent tool call ID (for nested tool calls).
    #[serde(rename = "parentToolCallId", skip_serializing_if = "Option::is_none")]
    pub parent_tool_call_id: Option<String>,

    /// List of tool requests from the assistant.
    #[serde(rename = "toolRequests", skip_serializing_if = "Option::is_none")]
    pub tool_requests: Option<Vec<ToolRequest>>,

    /// Total response size in bytes.
    #[serde(rename = "totalResponseSizeBytes", skip_serializing_if = "Option::is_none")]
    pub total_response_size_bytes: Option<f64>,

    /// API call identifier for tracking.
    #[serde(rename = "apiCallId", skip_serializing_if = "Option::is_none")]
    pub api_call_id: Option<String>,

    /// Tokens read from cache.
    #[serde(rename = "cacheReadTokens", skip_serializing_if = "Option::is_none")]
    pub cache_read_tokens: Option<f64>,

    /// Tokens written to cache.
    #[serde(rename = "cacheWriteTokens", skip_serializing_if = "Option::is_none")]
    pub cache_write_tokens: Option<f64>,

    /// Cost of the operation (in USD).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cost: Option<f64>,

    /// Duration of operation in milliseconds.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration: Option<f64>,

    /// Who initiated the operation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub initiator: Option<String>,

    /// Number of input tokens used.
    #[serde(rename = "inputTokens", skip_serializing_if = "Option::is_none")]
    pub input_tokens: Option<f64>,

    /// Model name used for the operation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<String>,

    /// Number of output tokens generated.
    #[serde(rename = "outputTokens", skip_serializing_if = "Option::is_none")]
    pub output_tokens: Option<f64>,

    /// Provider-specific call identifier.
    #[serde(rename = "providerCallId", skip_serializing_if = "Option::is_none")]
    pub provider_call_id: Option<String>,

    /// Quota usage snapshots by model.
    #[serde(rename = "quotaSnapshots", skip_serializing_if = "Option::is_none")]
    pub quota_snapshots: Option<HashMap<String, QuotaSnapshot>>,

    /// Reason for the event or action.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// Tool call arguments (JSON value).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Value>,

    /// Tool call identifier.
    #[serde(rename = "toolCallId", skip_serializing_if = "Option::is_none")]
    pub tool_call_id: Option<String>,

    /// Name of the tool being executed.
    #[serde(rename = "toolName", skip_serializing_if = "Option::is_none")]
    pub tool_name: Option<String>,

    /// Partial/intermediate tool output.
    #[serde(rename = "partialOutput", skip_serializing_if = "Option::is_none")]
    pub partial_output: Option<String>,

    /// Whether the tool was requested by the user.
    #[serde(rename = "isUserRequested", skip_serializing_if = "Option::is_none")]
    pub is_user_requested: Option<bool>,

    /// Tool execution result.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<ToolResultData>,

    /// Tool-specific telemetry data.
    #[serde(rename = "toolTelemetry", skip_serializing_if = "Option::is_none")]
    pub tool_telemetry: Option<HashMap<String, Value>>,

    /// Subagent description.
    #[serde(rename = "agentDescription", skip_serializing_if = "Option::is_none")]
    pub agent_description: Option<String>,

    /// Subagent display name.
    #[serde(rename = "agentDisplayName", skip_serializing_if = "Option::is_none")]
    pub agent_display_name: Option<String>,

    /// Subagent name identifier.
    #[serde(rename = "agentName", skip_serializing_if = "Option::is_none")]
    pub agent_name: Option<String>,

    /// List of available tools.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<String>>,

    /// Hook invocation identifier.
    #[serde(rename = "hookInvocationId", skip_serializing_if = "Option::is_none")]
    pub hook_invocation_id: Option<String>,

    /// Type of hook being executed.
    #[serde(rename = "hookType", skip_serializing_if = "Option::is_none")]
    pub hook_type: Option<String>,

    /// Input data for the operation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input: Option<Value>,

    /// Output data from the operation.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<Value>,

    /// Additional metadata.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,

    /// Name identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Message role (system, developer, etc.).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<Role>,
}

/// File or directory attachment in a message.
///
/// Attachments allow users to include files or directories as context
/// for their messages.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Attachment {
    /// Display name shown to the user.
    #[serde(rename = "displayName")]
    pub display_name: String,

    /// File system path to the attachment.
    pub path: String,

    /// Type of attachment (file or directory).
    #[serde(rename = "type")]
    pub attachment_type: AttachmentType,
}

/// Type of attachment.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AttachmentType {
    /// Directory attachment.
    Directory,
    /// File attachment.
    File,
}

/// Token usage information for compaction operations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompactionTokensUsed {
    /// Tokens read from cache during compaction.
    #[serde(rename = "cachedInput")]
    pub cached_input: f64,

    /// Input tokens used for compaction.
    pub input: f64,

    /// Output tokens generated during compaction.
    pub output: f64,
}

/// Context information - can be a simple string or detailed object.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextUnion {
    /// Simple string context.
    String(String),
    /// Detailed context object with working directory and git info.
    Object(ContextClass),
}

/// Detailed context information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextClass {
    /// Current git branch (if in a git repository).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,

    /// Current working directory.
    pub cwd: String,

    /// Git repository root directory.
    #[serde(rename = "gitRoot", skip_serializing_if = "Option::is_none")]
    pub git_root: Option<String>,

    /// Repository identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
}

/// Error information - can be a simple message or detailed object.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ErrorUnion {
    /// Simple error message string.
    String(String),
    /// Detailed error object with code and stack trace.
    Object(ErrorClass),
}

/// Detailed error information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorClass {
    /// Error code identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,

    /// Human-readable error message.
    pub message: String,

    /// Error stack trace (if available).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stack: Option<String>,
}

/// Additional metadata for system messages.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Metadata {
    /// Prompt version identifier.
    #[serde(rename = "promptVersion", skip_serializing_if = "Option::is_none")]
    pub prompt_version: Option<String>,

    /// Template variables used in the prompt.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variables: Option<HashMap<String, Value>>,
}

/// Quota usage snapshot for a model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuotaSnapshot {
    /// Number of entitlement requests.
    #[serde(rename = "entitlementRequests")]
    pub entitlement_requests: f64,

    /// Whether user has unlimited entitlement.
    #[serde(rename = "isUnlimitedEntitlement")]
    pub is_unlimited_entitlement: bool,

    /// Overage amount.
    pub overage: f64,

    /// Whether overage is allowed when quota is exhausted.
    #[serde(rename = "overageAllowedWithExhaustedQuota")]
    pub overage_allowed_with_exhausted_quota: bool,

    /// Percentage of quota remaining.
    #[serde(rename = "remainingPercentage")]
    pub remaining_percentage: f64,

    /// When the quota resets.
    #[serde(rename = "resetDate", skip_serializing_if = "Option::is_none")]
    pub reset_date: Option<DateTime<Utc>>,

    /// Whether usage is allowed when quota is exhausted.
    #[serde(rename = "usageAllowedWithExhaustedQuota")]
    pub usage_allowed_with_exhausted_quota: bool,

    /// Number of requests used.
    #[serde(rename = "usedRequests")]
    pub used_requests: f64,
}

/// Git repository information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Repository {
    /// Current branch name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,

    /// Repository name.
    pub name: String,

    /// Repository owner.
    pub owner: String,
}

/// Tool execution result data.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolResultData {
    /// Result content (usually displayed to the assistant).
    pub content: String,
}

/// Tool request from the assistant.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolRequest {
    /// Arguments to pass to the tool (as JSON).
    pub arguments: Value,

    /// Tool name.
    pub name: String,

    /// Unique identifier for this tool call.
    #[serde(rename = "toolCallId")]
    pub tool_call_id: String,

    /// Type of tool request.
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub request_type: Option<ToolRequestType>,
}

/// Type of tool request.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ToolRequestType {
    /// Custom tool type.
    Custom,
    /// Standard function tool.
    Function,
}

/// Source type for session events.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SourceType {
    /// Event originated locally.
    Local,
    /// Event originated from a remote source.
    Remote,
}

/// Message role.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// Developer-provided message.
    Developer,
    /// System-generated message.
    System,
}
