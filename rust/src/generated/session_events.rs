// AUTO-GENERATED FILE - DO NOT EDIT
//
// Generated from: @github/copilot/session-events.schema.json
// Generated by: scripts/generate-session-types.ts
//
// To update these types:
// 1. Update the schema in copilot-agent-runtime
// 2. Run: npm run generate:session-types

//! Session event types for the Copilot SDK.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Session event from the Copilot CLI.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionEvent {
    /// Event data.
    pub data: SessionEventData,

    /// Whether the event is ephemeral (not persisted).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ephemeral: Option<bool>,

    /// Unique event ID.
    pub id: String,

    /// Parent event ID (if this event is a child).
    #[serde(rename = "parentId")]
    pub parent_id: Option<String>,

    /// Event timestamp.
    pub timestamp: DateTime<Utc>,

    /// Event type.
    #[serde(rename = "type")]
    pub event_type: SessionEventType,
}

/// Session event types.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SessionEventType {
    #[serde(rename = "abort")]
    Abort,
    #[serde(rename = "assistant.intent")]
    AssistantIntent,
    #[serde(rename = "assistant.message")]
    AssistantMessage,
    #[serde(rename = "assistant.message_delta")]
    AssistantMessageDelta,
    #[serde(rename = "assistant.reasoning")]
    AssistantReasoning,
    #[serde(rename = "assistant.reasoning_delta")]
    AssistantReasoningDelta,
    #[serde(rename = "assistant.turn_end")]
    AssistantTurnEnd,
    #[serde(rename = "assistant.turn_start")]
    AssistantTurnStart,
    #[serde(rename = "assistant.usage")]
    AssistantUsage,
    #[serde(rename = "hook.end")]
    HookEnd,
    #[serde(rename = "hook.start")]
    HookStart,
    #[serde(rename = "pending_messages.modified")]
    PendingMessagesModified,
    #[serde(rename = "session.compaction_complete")]
    SessionCompactionComplete,
    #[serde(rename = "session.compaction_start")]
    SessionCompactionStart,
    #[serde(rename = "session.error")]
    SessionError,
    #[serde(rename = "session.handoff")]
    SessionHandoff,
    #[serde(rename = "session.idle")]
    SessionIdle,
    #[serde(rename = "session.info")]
    SessionInfo,
    #[serde(rename = "session.model_change")]
    SessionModelChange,
    #[serde(rename = "session.resume")]
    SessionResume,
    #[serde(rename = "session.start")]
    SessionStart,
    #[serde(rename = "session.truncation")]
    SessionTruncation,
    #[serde(rename = "session.usage_info")]
    SessionUsageInfo,
    #[serde(rename = "subagent.completed")]
    SubagentCompleted,
    #[serde(rename = "subagent.failed")]
    SubagentFailed,
    #[serde(rename = "subagent.selected")]
    SubagentSelected,
    #[serde(rename = "subagent.started")]
    SubagentStarted,
    #[serde(rename = "system.message")]
    SystemMessage,
    #[serde(rename = "tool.execution_complete")]
    ToolExecutionComplete,
    #[serde(rename = "tool.execution_partial_result")]
    ToolExecutionPartialResult,
    #[serde(rename = "tool.execution_start")]
    ToolExecutionStart,
    #[serde(rename = "tool.user_requested")]
    ToolUserRequested,
    #[serde(rename = "user.message")]
    UserMessage,
}

impl std::fmt::Display for SessionEventType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SessionEventType::Abort => write!(f, "abort"),
            SessionEventType::AssistantIntent => write!(f, "assistant.intent"),
            SessionEventType::AssistantMessage => write!(f, "assistant.message"),
            SessionEventType::AssistantMessageDelta => write!(f, "assistant.message_delta"),
            SessionEventType::AssistantReasoning => write!(f, "assistant.reasoning"),
            SessionEventType::AssistantReasoningDelta => write!(f, "assistant.reasoning_delta"),
            SessionEventType::AssistantTurnEnd => write!(f, "assistant.turn_end"),
            SessionEventType::AssistantTurnStart => write!(f, "assistant.turn_start"),
            SessionEventType::AssistantUsage => write!(f, "assistant.usage"),
            SessionEventType::HookEnd => write!(f, "hook.end"),
            SessionEventType::HookStart => write!(f, "hook.start"),
            SessionEventType::PendingMessagesModified => write!(f, "pending_messages.modified"),
            SessionEventType::SessionCompactionComplete => write!(f, "session.compaction_complete"),
            SessionEventType::SessionCompactionStart => write!(f, "session.compaction_start"),
            SessionEventType::SessionError => write!(f, "session.error"),
            SessionEventType::SessionHandoff => write!(f, "session.handoff"),
            SessionEventType::SessionIdle => write!(f, "session.idle"),
            SessionEventType::SessionInfo => write!(f, "session.info"),
            SessionEventType::SessionModelChange => write!(f, "session.model_change"),
            SessionEventType::SessionResume => write!(f, "session.resume"),
            SessionEventType::SessionStart => write!(f, "session.start"),
            SessionEventType::SessionTruncation => write!(f, "session.truncation"),
            SessionEventType::SessionUsageInfo => write!(f, "session.usage_info"),
            SessionEventType::SubagentCompleted => write!(f, "subagent.completed"),
            SessionEventType::SubagentFailed => write!(f, "subagent.failed"),
            SessionEventType::SubagentSelected => write!(f, "subagent.selected"),
            SessionEventType::SubagentStarted => write!(f, "subagent.started"),
            SessionEventType::SystemMessage => write!(f, "system.message"),
            SessionEventType::ToolExecutionComplete => write!(f, "tool.execution_complete"),
            SessionEventType::ToolExecutionPartialResult => write!(f, "tool.execution_partial_result"),
            SessionEventType::ToolExecutionStart => write!(f, "tool.execution_start"),
            SessionEventType::ToolUserRequested => write!(f, "tool.user_requested"),
            SessionEventType::UserMessage => write!(f, "user.message"),
        }
    }
}

/// Session event data - a flat structure containing all possible fields.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SessionEventData {
    /// Context information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<ContextUnion>,

    /// Copilot version.
    #[serde(rename = "copilotVersion", skip_serializing_if = "Option::is_none")]
    pub copilot_version: Option<String>,

    /// Event producer.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub producer: Option<String>,

    /// Selected model.
    #[serde(rename = "selectedModel", skip_serializing_if = "Option::is_none")]
    pub selected_model: Option<String>,

    /// Session ID.
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,

    /// Session start time.
    #[serde(rename = "startTime", skip_serializing_if = "Option::is_none")]
    pub start_time: Option<DateTime<Utc>>,

    /// Version number.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<f64>,

    /// Event count.
    #[serde(rename = "eventCount", skip_serializing_if = "Option::is_none")]
    pub event_count: Option<f64>,

    /// Resume time.
    #[serde(rename = "resumeTime", skip_serializing_if = "Option::is_none")]
    pub resume_time: Option<DateTime<Utc>>,

    /// Error type.
    #[serde(rename = "errorType", skip_serializing_if = "Option::is_none")]
    pub error_type: Option<String>,

    /// Message content.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,

    /// Stack trace.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stack: Option<String>,

    /// Info type.
    #[serde(rename = "infoType", skip_serializing_if = "Option::is_none")]
    pub info_type: Option<String>,

    /// New model (for model change events).
    #[serde(rename = "newModel", skip_serializing_if = "Option::is_none")]
    pub new_model: Option<String>,

    /// Previous model (for model change events).
    #[serde(rename = "previousModel", skip_serializing_if = "Option::is_none")]
    pub previous_model: Option<String>,

    /// Handoff time.
    #[serde(rename = "handoffTime", skip_serializing_if = "Option::is_none")]
    pub handoff_time: Option<DateTime<Utc>>,

    /// Remote session ID.
    #[serde(rename = "remoteSessionId", skip_serializing_if = "Option::is_none")]
    pub remote_session_id: Option<String>,

    /// Repository info.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repository: Option<Repository>,

    /// Source type.
    #[serde(rename = "sourceType", skip_serializing_if = "Option::is_none")]
    pub source_type: Option<SourceType>,

    /// Summary text.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,

    /// Messages removed during truncation.
    #[serde(rename = "messagesRemovedDuringTruncation", skip_serializing_if = "Option::is_none")]
    pub messages_removed_during_truncation: Option<f64>,

    /// Who performed the action.
    #[serde(rename = "performedBy", skip_serializing_if = "Option::is_none")]
    pub performed_by: Option<String>,

    /// Post-truncation messages length.
    #[serde(rename = "postTruncationMessagesLength", skip_serializing_if = "Option::is_none")]
    pub post_truncation_messages_length: Option<f64>,

    /// Post-truncation tokens.
    #[serde(rename = "postTruncationTokensInMessages", skip_serializing_if = "Option::is_none")]
    pub post_truncation_tokens_in_messages: Option<f64>,

    /// Pre-truncation messages length.
    #[serde(rename = "preTruncationMessagesLength", skip_serializing_if = "Option::is_none")]
    pub pre_truncation_messages_length: Option<f64>,

    /// Pre-truncation tokens.
    #[serde(rename = "preTruncationTokensInMessages", skip_serializing_if = "Option::is_none")]
    pub pre_truncation_tokens_in_messages: Option<f64>,

    /// Token limit.
    #[serde(rename = "tokenLimit", skip_serializing_if = "Option::is_none")]
    pub token_limit: Option<f64>,

    /// Tokens removed during truncation.
    #[serde(rename = "tokensRemovedDuringTruncation", skip_serializing_if = "Option::is_none")]
    pub tokens_removed_during_truncation: Option<f64>,

    /// Current token count.
    #[serde(rename = "currentTokens", skip_serializing_if = "Option::is_none")]
    pub current_tokens: Option<f64>,

    /// Messages length.
    #[serde(rename = "messagesLength", skip_serializing_if = "Option::is_none")]
    pub messages_length: Option<f64>,

    /// Compaction tokens used.
    #[serde(rename = "compactionTokensUsed", skip_serializing_if = "Option::is_none")]
    pub compaction_tokens_used: Option<CompactionTokensUsed>,

    /// Error information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ErrorUnion>,

    /// Messages removed.
    #[serde(rename = "messagesRemoved", skip_serializing_if = "Option::is_none")]
    pub messages_removed: Option<f64>,

    /// Post-compaction tokens.
    #[serde(rename = "postCompactionTokens", skip_serializing_if = "Option::is_none")]
    pub post_compaction_tokens: Option<f64>,

    /// Pre-compaction messages length.
    #[serde(rename = "preCompactionMessagesLength", skip_serializing_if = "Option::is_none")]
    pub pre_compaction_messages_length: Option<f64>,

    /// Pre-compaction tokens.
    #[serde(rename = "preCompactionTokens", skip_serializing_if = "Option::is_none")]
    pub pre_compaction_tokens: Option<f64>,

    /// Success flag.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success: Option<bool>,

    /// Summary content.
    #[serde(rename = "summaryContent", skip_serializing_if = "Option::is_none")]
    pub summary_content: Option<String>,

    /// Tokens removed.
    #[serde(rename = "tokensRemoved", skip_serializing_if = "Option::is_none")]
    pub tokens_removed: Option<f64>,

    /// Message attachments.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Vec<Attachment>>,

    /// Content text.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    /// Event source.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,

    /// Transformed content.
    #[serde(rename = "transformedContent", skip_serializing_if = "Option::is_none")]
    pub transformed_content: Option<String>,

    /// Turn ID.
    #[serde(rename = "turnId", skip_serializing_if = "Option::is_none")]
    pub turn_id: Option<String>,

    /// Intent.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub intent: Option<String>,

    /// Reasoning ID.
    #[serde(rename = "reasoningId", skip_serializing_if = "Option::is_none")]
    pub reasoning_id: Option<String>,

    /// Delta content (for streaming).
    #[serde(rename = "deltaContent", skip_serializing_if = "Option::is_none")]
    pub delta_content: Option<String>,

    /// Message ID.
    #[serde(rename = "messageId", skip_serializing_if = "Option::is_none")]
    pub message_id: Option<String>,

    /// Parent tool call ID.
    #[serde(rename = "parentToolCallId", skip_serializing_if = "Option::is_none")]
    pub parent_tool_call_id: Option<String>,

    /// Tool requests.
    #[serde(rename = "toolRequests", skip_serializing_if = "Option::is_none")]
    pub tool_requests: Option<Vec<ToolRequest>>,

    /// Total response size in bytes.
    #[serde(rename = "totalResponseSizeBytes", skip_serializing_if = "Option::is_none")]
    pub total_response_size_bytes: Option<f64>,

    /// API call ID.
    #[serde(rename = "apiCallId", skip_serializing_if = "Option::is_none")]
    pub api_call_id: Option<String>,

    /// Cache read tokens.
    #[serde(rename = "cacheReadTokens", skip_serializing_if = "Option::is_none")]
    pub cache_read_tokens: Option<f64>,

    /// Cache write tokens.
    #[serde(rename = "cacheWriteTokens", skip_serializing_if = "Option::is_none")]
    pub cache_write_tokens: Option<f64>,

    /// Cost.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cost: Option<f64>,

    /// Duration.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration: Option<f64>,

    /// Initiator.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub initiator: Option<String>,

    /// Input tokens.
    #[serde(rename = "inputTokens", skip_serializing_if = "Option::is_none")]
    pub input_tokens: Option<f64>,

    /// Model name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<String>,

    /// Output tokens.
    #[serde(rename = "outputTokens", skip_serializing_if = "Option::is_none")]
    pub output_tokens: Option<f64>,

    /// Provider call ID.
    #[serde(rename = "providerCallId", skip_serializing_if = "Option::is_none")]
    pub provider_call_id: Option<String>,

    /// Quota snapshots.
    #[serde(rename = "quotaSnapshots", skip_serializing_if = "Option::is_none")]
    pub quota_snapshots: Option<HashMap<String, QuotaSnapshot>>,

    /// Reason.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,

    /// Tool call arguments.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<Value>,

    /// Tool call ID.
    #[serde(rename = "toolCallId", skip_serializing_if = "Option::is_none")]
    pub tool_call_id: Option<String>,

    /// Tool name.
    #[serde(rename = "toolName", skip_serializing_if = "Option::is_none")]
    pub tool_name: Option<String>,

    /// Partial output.
    #[serde(rename = "partialOutput", skip_serializing_if = "Option::is_none")]
    pub partial_output: Option<String>,

    /// Whether user requested.
    #[serde(rename = "isUserRequested", skip_serializing_if = "Option::is_none")]
    pub is_user_requested: Option<bool>,

    /// Tool result.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<ToolResultData>,

    /// Tool telemetry.
    #[serde(rename = "toolTelemetry", skip_serializing_if = "Option::is_none")]
    pub tool_telemetry: Option<HashMap<String, Value>>,

    /// Agent description.
    #[serde(rename = "agentDescription", skip_serializing_if = "Option::is_none")]
    pub agent_description: Option<String>,

    /// Agent display name.
    #[serde(rename = "agentDisplayName", skip_serializing_if = "Option::is_none")]
    pub agent_display_name: Option<String>,

    /// Agent name.
    #[serde(rename = "agentName", skip_serializing_if = "Option::is_none")]
    pub agent_name: Option<String>,

    /// Tools list.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<String>>,

    /// Hook invocation ID.
    #[serde(rename = "hookInvocationId", skip_serializing_if = "Option::is_none")]
    pub hook_invocation_id: Option<String>,

    /// Hook type.
    #[serde(rename = "hookType", skip_serializing_if = "Option::is_none")]
    pub hook_type: Option<String>,

    /// Input data.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input: Option<Value>,

    /// Output data.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<Value>,

    /// Metadata.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<Metadata>,

    /// Name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Role.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<Role>,
}

/// Attachment in session event data.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Attachment {
    #[serde(rename = "displayName")]
    pub display_name: String,
    pub path: String,
    #[serde(rename = "type")]
    pub attachment_type: AttachmentType,
}

/// Attachment type.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum AttachmentType {
    Directory,
    File,
}

/// Compaction tokens used.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompactionTokensUsed {
    #[serde(rename = "cachedInput")]
    pub cached_input: f64,
    pub input: f64,
    pub output: f64,
}

/// Context information (can be string or object).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ContextUnion {
    String(String),
    Object(ContextClass),
}

/// Context object.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextClass {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,
    pub cwd: String,
    #[serde(rename = "gitRoot", skip_serializing_if = "Option::is_none")]
    pub git_root: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repository: Option<String>,
}

/// Error information (can be string or object).
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ErrorUnion {
    String(String),
    Object(ErrorClass),
}

/// Error object.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorClass {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stack: Option<String>,
}

/// Metadata.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Metadata {
    #[serde(rename = "promptVersion", skip_serializing_if = "Option::is_none")]
    pub prompt_version: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variables: Option<HashMap<String, Value>>,
}

/// Quota snapshot.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuotaSnapshot {
    #[serde(rename = "entitlementRequests")]
    pub entitlement_requests: f64,
    #[serde(rename = "isUnlimitedEntitlement")]
    pub is_unlimited_entitlement: bool,
    pub overage: f64,
    #[serde(rename = "overageAllowedWithExhaustedQuota")]
    pub overage_allowed_with_exhausted_quota: bool,
    #[serde(rename = "remainingPercentage")]
    pub remaining_percentage: f64,
    #[serde(rename = "resetDate", skip_serializing_if = "Option::is_none")]
    pub reset_date: Option<DateTime<Utc>>,
    #[serde(rename = "usageAllowedWithExhaustedQuota")]
    pub usage_allowed_with_exhausted_quota: bool,
    #[serde(rename = "usedRequests")]
    pub used_requests: f64,
}

/// Repository information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Repository {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub branch: Option<String>,
    pub name: String,
    pub owner: String,
}

/// Tool result data.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolResultData {
    pub content: String,
}

/// Tool request.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolRequest {
    pub arguments: Value,
    pub name: String,
    #[serde(rename = "toolCallId")]
    pub tool_call_id: String,
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    pub request_type: Option<ToolRequestType>,
}

/// Tool request type.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ToolRequestType {
    Custom,
    Function,
}

/// Source type.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SourceType {
    Local,
    Remote,
}

/// Role.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    Developer,
    System,
}
